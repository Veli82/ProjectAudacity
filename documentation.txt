Така,

В момента на писане на този текст, часа е точно 11:30 на 20.06.2025г.
Благодаря много на доц. Армянов че се съгласи да удължи срока. Въпреки това, аз не успях да напиша документацията на време,
защото свърших с писането на кода преди 30 мин. В тези 30 мин аз се опитах да подкарам doxygen, не успях, сетих се че нямам инсталиран 7-zip,
след това се сетих че дори нямам офис пакет и дори не мога да направя .docx файл за тая документация нито pdf.
Дотук доста трагично.
Въпреки това, за останалите вече 25 мин ще се постарая да напиша тук каквото ми дойде на ума. (вече изтрито)
Ако все пак искате "смислена" документация, ще направя google docs и ще се прехвърля да пиша на него, веднага щом изтече времето и предам проекта.

Линк за там: https://docs.google.com/document/d/137MkNgLe1dpo79b3XGah1-bJ7sdaVsbl5H0VZ2Yby0s/edit?usp=sharing


<Текстът от Гугъл дока - директен copy-paste>
Много много се надявам да оцените труда ми за тази документация и да я прочетете въпреки късното предаване.

Анализ на задачата:

Идеята на проекта е да се създаде система за обработка на дигитално аудио, подобна на Audacity.
Интерфейсът и обаче е реализиран изцяло в конзолата :)

Как работи един дигитален звук набързо:
(не знам кой ще го проверява този проект, може да си няма идея)
Звука по принцип е вълна с честота (20 - 20000 Hz - поне тези чуваме) и амплитуда.
Звукът се съхранява дигитално, като се вземат проби (samples) през много малък интервал от време (Sample rate - брой на проби в секунда (в Hz)), които представляват амплитудата на вълната в момента на вземане на пробата и я записват като дробно число между 1 и -1.
Общият брой на пробите е = Sample rate * времето на звука в секунди.

Как работи .wav формата набързо:
В header-a на .wav файла има информация за звука (като Sample Rate, дължина и др.) а след това са записани всичките проби на звука. Те може да са записани като 8-bit unsigned ints, 16-bit / 24-bit / 32-bit signed int. От там трябва да се преобразуват във float за да се вземе оригиналната им стойност. Аудиото може да е mono, stereo и тн.
Много добър reference: http://soundfile.sapp.org/doc/WaveFormat/ 


Класовете на бързо:
Основната на класовата архитектура е абстрактния базов клас Sound.
Негови деца са също класовете:
1.Silence - тишина, с константна амплитуда 0
2.FileSound - звук, извлечен от файл (. формат)
3.EffectSound - ефект, който манипулира пробите на звука, върху който е приложен
4.GeneratedSound - звук, генериран от компютъра с параметри от потребителя
Като последните 3 също са абстрактни, техните наследници реализират самите обекти с които програмата ще работи.

Имаме клас Track, който трябва да бъде линейна последователност от звуци.
Имаме клас Project, който е масив от тракове, които управлява, обработва и експортва. В него е потребителския интерфейс.

След много мислене и работа по този проект ще си позволя да кажа, че условието е доста неописателно. Много подробности не са казани и са оставени на програмиста сам да помисли как да ги имплементира. Това е готино и предизвикателно, но все пак трябва да е в някакви разумни граници. Така де rant over.

След няколко дискутирания с доц. Армянов стигнахме до важни уточнения, които оказаха голямо влияние при мислене на архитектурата:


Със сигурност не трябва да зареждаме всички проби в паметта!!!
Следователно, експортването на звука ще се извършва проба по проба с нещо като .getSample()
Ефектът трябва да е (наследник на) звук (за да е добра ООП ориентирана задача) въпреки факта, че по същество той не е звук, а манипулация на вече съществуващ такъв
Трябва да може да се слага ефект върху част от звук/звуци. Тоест да може да кажеш сложи ми ефект от секунда х до секунда у и той да се приложи върху звуците там, без да го интересува какви са те.

Та с тези уточнения в ума дълго мислих как ще реализирам исканите от мен функционалности.
Отделих много време да си отговоря на 2 въпроса:
1.Как един ефект ще знае точно върху кои звуци е приложен?
2.Как ще се подреждат звуците в track-a, така че когато стане време за експортване, да се извлекат правилните проби в правилния ред? 

Гледайки точка 4 от по горе и факта, че при добавяне на обикновенни звуци те също могат да се застъпват (с преливане), реших, че ще е яко да мога да добавям звук в един трак където поискам, и той да се редактира автоматично, така че да знае винаги, кои звуци са “най отгоре на стака”. Нещо като интерфейса на Audacity за визуализацията на траковете. (Това на лист хартия много по-лесно се обяснява)
 
Та стигнах до извода, че трябва да имам начин да избера само една конкретна част от един звук.
Тук родих моята идея, от която съм много горд и която е сърцето на архитектурата ми от тук нататък.
Класът SoundChunk. На езика на C++ това е просто клас с указател към обект звук и две цели числа - начална проба и крайна проба (спрямо пробите на звука към който сочи). Така мога да взема примерно един звук със 100 проби и да направя soundChunk, който да представлява звука от 30-тата проба до 70-тата. На повърхността, това е един звук с 40 проби и мен не ме интересува какво се случва отдолу. Когато взема първата проба на chunk-a реално вземам 30-тата на звука.
В последствие се оказа че моят клас SoundChunk е страхотен пример за proxy class, просто аз още не знаех че се казва така.

Нека разгледаме по подробно архитектурата:
Абстрактния клас Звук има една основна виртуална функция:
sound.getSample(int index)
Тя приема номер на проба от 0 до общия борй на пробите в звука -1 и връща нейната стойност.
Всеки клас имплементира тази функция напълно различно.
- Silence - винаги връща 0
- FileSound - с помощта на std::ifstream обект чете от файл със звук
- GeneratedSound - изчислява с математически формули стойността на пробата
- EffectSound - извлича съответната проба от звуците, върху които е приложен, прилага и някаква трансформация и връща резултата.

Тук идва първата важна роля на SoundChunk - базовите звуци, върху които ефекта е създаден, се записват като масив от SoundChunk обекти вътре в ефект обекта.
Двете основни функции на ефекта са:
-getSampleFromBase(int index) - извлича съответната проба от звуците, върху които е приложен
-applyEffect(float sample) - виртуалната функция, която всеки ефект имплементира.

Минаваме към класа Track: втората важна роля на SoundChunk - трака, който в същността си е полиморфен контейнер от звуци, вместо масив от Sound* е масив от SoundChunks, който реално също е масив от указатели, но ни позволява важното удобство да избираме само част от даден звук. По този начин при добавяне на звук върху трака, на вече запълнено място, околните звуци (вече чънкове) могат автоматично да се преоразмерят/изтрият напълно за да се поддържа актуално състояние на кой звук (и коя част от него) е най-отгоре ⇒ от кой звук (и коя част от него) трябва да започне извличането на проби. Много важно е да отбележим,че оригиналните звукови обекти остават непроменени! Те даже могат да бъдат декларирани като константни!

От тези изброени свойства получаваме няколко изненадващо приятни факта:
- Много чънкове може да сочат към един звук. Това улеснява копирането и преизползването на един и същи звук. (Пр: когато имаме много ефекти върху 1 звук) Не е нужно да създаваме нов обект.
- В следствие на това, при копирането на трак, shallow copy е напълно ОК!!! Това прави операцията много по-“евтина” и лесна за имплементация.
- Копирането по този начин ни предпазва от хвърляне на изключения (Вместо да викаме копиращ к-тор или оп= на звуците, които кой знае какво може да хвърлят, копираме лек и изцяло стеков обект)

Минус на архитектурата на трака е, че добавянето на звук е деструктивна операция и не може да бъде revert-нато. Следователно, няма undo функционалност, която така или иначе не се изисква в условието. Но пък обектът е лек което ще позволи лесна имплементация на запазване на история на промени.

Последния клас Project: Неговата роля също е много важна. Освен, че е контейнер за траковете, той също има и масив, в който държи указател към всеки един динамично заделен звук, добавен към проекта, за да управлява жизнения му цикъл. Освен това тук е и целия потребителски интерфейс. Той има функционалността да се записва в двоичен файл (save project) и по-късно прочита отново (load project), за да се възстанови прогреса на потребителя, точно като истинско приложение.
Естествено, споменавайки “като истинско приложение” трябва да отбележим основната функкция на проекта, експортване на проекта (или даден трак) в .wav формат, който може да бъде възпроизведен както всеки друг .wav файл!


Основния flow на добавяне на звук в проекта е такъв:
Потребителя създава звук с подадени от него параметри, той се създава динамично и се връзва с указател към проекта. След това той се добавя към някой от траковете, по начин избран от потребителя, като се използва вече споменатата логика на трака. При този процес са възможни създаването на допълнителни звуци (тишина, ефект преливане), които също се заделят динамично
.
Идеята на цялото нещо е, че когато се натрупват звуците един върху друг, трака държи указатели към най горния слой, а звуците от този слой държат указатели към звуците под тях. Така всички звуци се свързват като верига един за друг, запазвайки реда си на добавяне и мястото, което заемат в трака. Когато експортването започне, се вика .getSample(int index) на всяка проба на звуците от най-горния слой, а те рекурсивно (по-скоро дървовидно) викат getSample() на звуците под тях.
Така се получава едно красиво полиморфно поведение, което позволява експортването на трак да е едва 20 реда код, въпреки сложните функционалностти, които трака поддържа. 
Много якооо ааааа???


Неща, които много ми се искаше да направя, но просто не ми стигна времето за тях:
(“Идеи за бъдещи подобрения”)
Визуализация на проекта, за по лесна работа с програмата (подобна на audacity)
Повече ефекти
Още един файлов формат
Функционалност за прилагане на ефекти, които не могат да се приложат на принципа perSample
Променяне нa конструктора на класа Sound (*)
(*) Трябваше двата параметъра да са sampleRate и numOfSamples, а duration да се калкулира от тях. Може да се види, че 3те стойности са взаимно зависими (от всеки 2 може да се получи третата). По коректно щеше обаче да се работи с горепосочените 2, защото са цели числа. В момента е възможно да се получават някакви леки разминавания в броя проби при някои операции (въпреки че би трябвало да са сведени до минимум). Искам да отбележа голямото ми старание за точното изчисление (отновно доколкото е възможно) на броя проби, особено при преоразмеряване на SoundChunks.



Финални мисли:
Ако някой си е направил труда да го прочете това цялото нещо, благодаря.
Ако този някой е човека, който ще ми оценява проекта, дано съм успял да му предам всичките проблеми и мъките, които ми създадоха, да обоснова всичките решения, които съм взел за справянето ми с тези проблеми и да го накарам да усети поне малка част от цялото удовлетворение, което изпитах работейки по този проект.

Honorable mention:
Знам, че не ми е оправдание ама аз да си го кажа,
В последните 14 часа преди края на срока бяха направени:
тестване на Project::addSound()
Project::addEffect() + тестване (то за всички де)
Project::exportProject() //букв днес разбрах, че ми трябва нормализация
Тестване и подсигуряване на потребителския вход против крашове (Колкото могааа)
Всичко за Project::saveProject и loadProject к-тора (общо за около 5 часа, което е просто уау) //ама почти не е тествано това
Жалък опит за документация
Та тази част от проекта не е толкова изпипана.

Край на писане на документация:
3:45 часа сутринта на 21.06.2025;
